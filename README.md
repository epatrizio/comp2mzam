# comp2mzam - Imperative language compiler to the Mini-ZAM

Here is a compiler producing bytecode for a simplified implementation of the OCaml Virtual Machine, called Mini-ZAM.

*This project is part of the Advanced Compilation course of my professional training at Sorbonne University (2022).*

## Technical stack / choices

I made the choice of OCaml ecosystem for the compiler implementation :

* [OCaml V4.13.1](https://ocaml.org)
  * [OCamlLex standard component for lexical analysis](https://ocaml.org/manual/lexyacc.html)
* [Menhir 20211230 tool for syntax analysis](https://gitlab.inria.fr/fpottier/menhir)
  * Use [OPAM 2.1.1 Ocaml PAckage Manager](https://opam.ocaml.org/packages/menhir) for Menhir installation

## Type system

From [version 1.1](https://github.com/epatrizio/comp2mzam/releases),
I added a typer to the compiler, it launches just before the compilation process.\
Typing is a fundamental component of the programming language specification,
called the [type system](https://en.wikipedia.org/wiki/Type_system).
So, I took advantage of this project to start learning typing concepts.

In summary, on the one hand there is **strong typing**.
We must give the type of each variable, each function argument, etc. It is very rigorous, safe, but very constraining.
On the other hand, there is **weak typing**, allowing more freedom, but which can cause big problems
if programmers do not apply strict coding rules.\
[See more details](https://en.wikipedia.org/wiki/Strong_and_weak_typing).

Fortunately, there is a middle way, probably the most advanced, used in functional languages:
**polymorphic types** and **inference**. Expressions will define dynamically the variables types,
or the possible types until a decision is made as late as possible.
It is very powerful because it allows to define (for example) multi-types (polymorphic)
functions while being type-safe.
To do this, there are classic algorithms, not easy to implement, such as the inference *algorithm W*.\
See more details with [Hindleyâ€“Milner type system](https://en.wikipedia.org/wiki/Hindley%E2%80%93Milner_type_system).

In conclusion, typing is a complex dimension of programming languages, very powerful.
Fun fact, in functional programming, there is an expression that says, "type-directed programming"!

## Compilation and execution

To compile the project source code, run the default Makefile command

```console
make
```

To execute the project (bytecode generation for the Mini-ZAM), run this command.\
In the following example, tests/t0.txt file is compiled to tests/build/bc_t0.txt file.\
To get an idea of the result, see the bytecode sample file tests/build/demo-bytecode.txt

```console
S=t0.txt make compile
```

```console
S=t0.txt make compile_no_typing
```

Then, you need a Mini-ZAM to interpret the generated bytecode.
